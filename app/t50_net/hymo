acu_com.c:				ad->hymo = pri;
acu_com.c:		//if((val[1] & 0x02) && (!adIsNonNull(ad) || !ad->cfg->AuxLockEnable)) {
acuobj.c:		if(val & 0x10) ad->
ad.c:		ad->cls			= CLS_ACCESS_DOOR;
ad.c:		ad->id			= i;
ad.c:		//ad->presentValue	= S_NORMAL_LOCKED;
ad.c:		ad->cfg			= &sys_cfg->accessDoors[i];
ad.c:		ad->alarmState	= 0;
ad.c:		ad->pv			= 0;	// Relinquish default
ad.c:		ad->priority	= 8;	// Relinquish default
ad.c:		ad->priorityMsk	= 0;
ad.c:		ad->priorityVal	= 0;
ad.c:	return (int)ad->id;
ad.c:	id = ad->id;
ad.c:	id = ad->id;
ad.c:	id = ad->id;
ad.c:	_AdSetDefault(ad->cfg);
ad.c:printf("adDelete...%d\n", (int)ad->id);
ad.c:	_AdDelete((int)ad->id);
ad.c:	id = ad->id;
ad.c:	id = ad->id;
ad.c:	id = ad->id;
ad.c:	id = ad->id;
ad.c:	id = ad->id;
ad.c:	return (int)ad->cfg->doorPulseTime;
ad.c:	ad->cfg->doorPulseTime = doorPulseTime;
ad.c:	return (int)ad->cfg->doorExPulseTime;
ad.c:	ad->cfg->doorExPulseTime = doorExtendedPulseTime;
ad.c:	return (int)ad->cfg->lockType;
ad.c:	ad->cfg->lockType = lockType;
ad.c:	return (int)ad->cfg->eventDetectionEnable;
ad.c:	ad->cfg->eventDetectionEnable = enable;
ad.c:	return (int)ad->cfg->timeDelay;
ad.c:	ad->cfg->timeDelay = timeDelay;
ad.c:	return (int)ad->cfg->timeDelayNormal;
ad.c:	ad->cfg->timeDelayNormal = timeDelayNormal;
ad.c:	return (int)ad->cfg->doorOpenTooLongEnable;
ad.c:	ad->cfg->doorOpenTooLongEnable = enable;
ad.c:	return (int)ad->cfg->doorOpenTooLongTime;
ad.c:	ad->cfg->doorOpenTooLongTime = doorOpenTooLongTime;
ad.c:	return (int)ad->cfg->forcedOpenEnable;
ad.c:	ad->cfg->forcedOpenEnable = enable;
ad.c:	aaId = ad->cfg->alarmAction;
ad.c:		aaId = 0; ad->cfg->alarmAction = aaId;
ad.c:	ad->cfg->alarmAction = aaId;
ad.c:	return (int)ad->cfg->unlockScheID;
ad.c:	ad->cfg->unlockScheID = unlockScheID;
ad.c:	return (int)ad->cfg->lockScheID;
ad.c:	ad->cfg->lockScheID = lockScheID;
ad.c:	return (int)ad->cfg->rtePriority;
ad.c:	ad->cfg->rtePriority = rtePriority;
ad.c:	msk = ad->priority;
ad.c:		priorityArray[i] = ad->pv;
ad.c:			if(ad->priorityMsk & msk) { 
ad.c:				if(ad->priorityVal & msk) pv = 1; else pv = 0;
ad.c:	ad->priorityMsk = ad->priorityVal = 0x00;
ad.c:		ad->priority = i;
ad.c:		ad->pv = priorityArray[i];
ad.c:				ad->priorityMsk |= msk;
ad.c:				if(priorityArray[i] > 0) ad->priorityVal |= msk;
ad.c:		ad->priority = 8; ad->pv = 0;	
ad.c://printf("adSetPriorityArray: pri=%d pv=%d\n", (int)ad->priority, (int)ad->pv);
ad.c:	return (int)ad->pv;
ad.c:	priority = ad->priority + 1;
ad.c:	priority--; opriority = ad->priority;
ad.c:	else if(priority == opriority) pv = ad->pv;
ad.c:		if(ad->priorityMsk & msk) { 
ad.c:			if(ad->priorityVal & msk) pv = 1; else pv = 0;
ad.c:	opv = ad->pv; opriority = ad->priority;
ad.c:			ad->priorityMsk |= msk;
ad.c:			if(opv) ad->priorityVal |= msk; else ad->priorityVal &= ~msk;
ad.c:		ad->pv = pv; ad->priority = priority;
ad.c:			ad->pv = pv; ad->priority = priority;
ad.c:			if(ad->priorityMsk & msk) {
ad.c:				if(ad->priorityVal & msk) opv = 1; else opv = 0;
ad.c:					ad->priorityVal ^= msk; val = 1;
ad.c:				ad->priorityMsk |= msk;
ad.c:				if(pv) ad->priorityVal |= msk; else ad->priorityVal &= ~msk;  
ad.c:	opv = ad->pv; opriority = ad->priority;
ad.c:			if(ad->priorityMsk & msk) break;
ad.c:			if(ad->priorityVal & msk) pv = 1;
ad.c:			ad->priorityMsk &= ~msk;
ad.c:		ad->priority = priority; ad->pv = pv;
ad.c:		if(ad->priorityMsk & msk) {
ad.c:			ad->priorityMsk &= ~msk; val = 1;
ad.c:	return (int)ad->alarmState;
ad.c:	ad->alarmState = (unsigned char)alarm;
adcfg.c:	return (int)ad->cfg->doorPulseTime;
adcfg.c:	ad->cfg->doorPulseTime = doorPulseTime;
adcfg.c:	return (int)ad->cfg->doorExPulseTime;
adcfg.c:	ad->cfg->doorExPulseTime = doorExPulseTime;
adcfg.c:	return (int)ad->cfg->lockType;
adcfg.c:	ad->cfg->lockType = lockType;
adcfg.c:	return (int)ad->cfg->eventDetectionEnable;
adcfg.c:	ad->cfg->eventDetectionEnable = enable;
adcfg.c:	return (int)ad->cfg->timeDelay;
adcfg.c:	ad->cfg->timeDelay = timeDelay;
adcfg.c:	return (int)ad->cfg->timeDelayNormal;
adcfg.c:	ad->cfg->timeDelayNormal = timeDelayNormal;
adcfg.c:	return (int)ad->cfg->doorOpenTooLongEnable;
adcfg.c:	ad->cfg->doorOpenTooLongEnable = enable;
adcfg.c:	ocID = ad->cfg->doorOpenTooLongOC;
adcfg.c:	ad->cfg->doorOpenTooLongOC = ocID;
adcfg.c:	return (int)ad->cfg->doorOpenTooLongTime;
adcfg.c:	ad->cfg->doorOpenTooLongTime = doorOpenTooLongTime;
adcfg.c:	return (int)ad->cfg->forcedOpenEnable;
adcfg.c:	ad->cfg->forcedOpenEnable = enable;
adcfg.c:	ocID = ad->cfg->forcedOpenOC;
adcfg.c:	ad->cfg->forcedOpenOC = ocID;
adcfg.c:	return (int)ad->cfg->unlockScheID;
adcfg.c:	ad->cfg->unlockScheID = unlockScheID;
adcfg.c:	return (int)ad->cfg->lockScheID;
adcfg.c:	ad->cfg->lockScheID = lockScheID;
adcfg.c:	return (int)ad->output;
adcfg.c:	ad->output = ocID;
adcfg.c:	return (int)ad->alarm;
adcfg.c:	ad->alarm = alarmID;
adcfg.c:	return (int)ad->presentValue;
adcfg.c:printf("%ld PresentValue: %d => %d\n", MS_TIMER, (int)ad->presentValue, presentValue);
adcfg.c:	if(presentValue == S_NORMAL_UNLOCKED || presentValue != ad->presentValue) {
adcfg.c:		ad->presentValue = presentValue;
adcfg.c:	return (int)ad->alarm;
adcfg.c:	ad->prevPV = ad->presentValue = S_NORMAL_LOCKED;
adcfg.c:	ad->alarm = 0;
admod.c:	val = ad->priorityArray[(priority-1)>>1];
admod.c:	opv = ad->pv; opriority = ad->priority;
admod.c:			if(opriority & 1) ad->priorityArray[i] |= 0xf0;
admod.c:			else			  ad->priorityArray[i] |= 0x0f;
admod.c:	val = ad->priorityArray[i];
admod.c:	ad->priorityArray[i] = val;
admod.c:		pv = ad->priorityArray[i] >> 4;
admod.c:		pv = ad->priorityArray[i] & 0x0f;
admod.c:		pv = 0; ad->priority = priority; priority = 8;
admod.c:	} else ad->priority = priority;
admod.c:	ad->pv = pv;
admod.c:	opv = ad->pv; priority = ad->priority;
admod.c:		if(priority & 1) ad->priorityArray[i] |= 0xf0;
admod.c:		else			 ad->priorityArray[i] |= 0x0f;
admod.c:			pv = ad->priorityArray[i] >> 4;
admod.c:			pv = ad->priorityArray[i] & 0x0f;
admod.c:			pv = 0; ad->priority = priority; priority = 8;
admod.c:		} else ad->priority = priority;
admod.c:		ad->pv = pv;
admod.c:	} else if(opv < 2 && pv > 1 || opv > 1 && pv > 1 && !ad->rte) {
admod.c:		val = ad->priorityArray[(priority-1)>>1];
admod.c:		val = ad->priorityArray[i];
admod.c:		ad->priorityArray[i] = val;
admod.c:		ad->rte = 1;
admod.c:		ad->pv = pv; ad->priority = priority;
adt.c:		pv = ad->priorityArray[i] >> 4;
adt.c:		pv = ad->priorityArray[i] & 0x0f;
adt.c:		opv = ad->priorityArray[i] >> 4;
adt.c:		opv = ad->priorityArray[i] & 0x0f;
adt.c:	val = ad->priorityArray[i];
adt.c:	ad->priorityArray[i] = val;
hwprim.c:	if(devLocalUnitModel(NULL) || ad->id) {
hwprim.c:		unit = unitsGet(CH2UNIT(ad->id));
hwprim.c:	if(devLocalUnitModel(NULL) || ad->id) {
hwprim.c:		*p++ = (ad->id & 3) + '1'; *p++ = '-';
uu.c:	if(ad->cfg->DoorEnable) {
uu.c:		val = ad->PV << 6; 	// DoorPV
uu.c:		c = ad->State;
uu.c:	if((!ad->cfg->DoorEnable || !ad->cfg->RequestToExitEnable) && (PV && !biTimeout[0] || !PV && biTimeout[0])) val |= 0x04;
uu.c:	if((!ad->cfg->DoorEnable || !ad->cfg->DoorStatusEnable) && (PV && !biTimeout[1] || !PV && biTimeout[1])) val |= 0x01;
uu.c:		if((val1 & 0xf8) && ad->cfg->DoorEnable) {
uu.c:		if((val1 & 0x04) && !ad->cfg->DoorEnable) {
uu.c:		if((val1 & 0x02) && (!ad->cfg->DoorEnable || !ad->cfg->AuxLockEnable)) {
